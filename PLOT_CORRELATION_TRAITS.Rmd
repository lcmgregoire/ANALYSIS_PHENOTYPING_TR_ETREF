---
title: "Correlation traits "
author: "Laura Gregoire"
date: "`r Sys.Date()`"
output:
  pdf_document:
    latex_engine: xelatex
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
options(repos = c(CRAN = "https://cran.r-project.org"))
# install.packages("tinytex")
# tinytex::install_tinytex()
tinytex::is_tinytex()
rm(list = ls())
```



```{r wd librairies}


library ("corrplot")  # for corelation plot
library("RColorBrewer") # for colorblind-friendly and high-contrast colors
library("dplyr")
library("smplot2")

here::here()

opPATH.obj= "./saved_objects/"
  if (!dir.exists(opPATH.obj)) dir.create(opPATH.obj, recursive = TRUE)


opPATH.results= "./results/"
  if (!dir.exists(opPATH.results)) dir.create(opPATH.results, recursive = TRUE)


opPATH.data= "./data/"
  if (!dir.exists(opPATH.data)) dir.create(opPATH.data, recursive = TRUE)


opPATH.fig= "./figures/"
  if (!dir.exists(opPATH.fig)) dir.create(opPATH.fig, recursive = TRUE)
```

#### sorghum trials correlations (HTP 2023, LTP 2024, Lysimeter 2024)


```{r import sorghum data }
# SORGHUM 

PHENO_LTP_SG= read.table(here::here(opPATH.results, "PHENO_LTP.txt"), header = TRUE)
names(PHENO_LTP_SG)[names(PHENO_LTP_SG) == "Code_ADN"] <- "GENO_NAME" # to differentiate between the slopes of the two trials
names(PHENO_LTP_SG)[names(PHENO_LTP_SG) == "ESTIMATE_THIES"] <- "Slope LTP" # to differentiate between the slopes of the two trials
names(PHENO_LTP_SG)[names(PHENO_LTP_SG) == "RS_RATIO"] <- "Root Shoot" # to differentiate between the slopes of the two trials
names(PHENO_LTP_SG)[names(PHENO_LTP_SG) == "ROOT_AREA"] <- "Root area" # to differentiate between the slopes of the two trials

nrow(PHENO_LTP_SG)

# HTP 2023
SLOPE_mean_HTP_SG= read.table(here::here(opPATH.results, "PHENO_HTP.txt"), header = TRUE)
names(SLOPE_mean_HTP_SG)[names(SLOPE_mean_HTP_SG) == "GENOTYPE"] <- "GENO_NAME" # to differentiate between the slopes of the two trials
names(SLOPE_mean_HTP_SG)[names(SLOPE_mean_HTP_SG) == "ESTIMATE_HTP"] <- "Slope HTP" # to differentiate between the slopes of the two trials
nrow(SLOPE_mean_HTP_SG)

## LYSI 
SLOPE_mean_LYSI_SG <- read.csv(here::here(opPATH.results, "PHENO_LYSI.txt"), header = TRUE, sep = "")
names(SLOPE_mean_LYSI_SG)[names(SLOPE_mean_LYSI_SG) == "Code_ADN"] <- "GENO_NAME"  # to differentiate between the slopes of the two trials
SLOPE_mean_LYSI_SG$ESTIMATE_BAMBEY = as.numeric(SLOPE_mean_LYSI_SG$ESTIMATE_BAMBEY)
names(SLOPE_mean_LYSI_SG)[names(SLOPE_mean_LYSI_SG) == "ESTIMATE_BAMBEY"] <- "Slope Lysimeter" # to differentiate between the slopes of the two trials
names(SLOPE_mean_LYSI_SG)[names(SLOPE_mean_LYSI_SG) == "TE"] <- "TEplant" # to differentiate between the slopes of the two trials


# create a list all  dfs
data_SG_list <- list(PHENO_LTP_SG, SLOPE_mean_LYSI_SG, SLOPE_mean_HTP_SG ) 
save(data_SG_list, file =  paste0(opPATH.obj, "data_SG_list.RData"))



# Merge them all by N_GENO and GENO_NAME

data_SG <- Reduce(function(x, y) merge(x, y, by = c( "GENO_NAME"), all = TRUE), data_SG_list) # to fix correlactly find N_GENO for GENO NAME in HTP df 
nrow(data_SG)

data_SG$N_GENO = as.factor(data_SG$N_GENO)
data_SG$GENO_NAME = as.factor(data_SG$GENO_NAME)

data_SG <- subset(data_SG, select = -c(WEEK, GENOTYPE )) ## remove N_GENO suuplementary 



data_SG <- data_SG %>% relocate(N_GENO, .after = 1)

save(data_SG, file =  paste0(opPATH.obj, "data_SG.RData"))
data_SG = na.omit(data_SG) ## only the common genotypes


data_SG_subset <- na.omit(data_SG[, 3:ncol(data_SG)]) ## does not accept NA 
# Recompute correlation and p-values
cor_SG <- cor(data_SG_subset, method = "pearson")  ##  Compute correlations and p-values
res_SG <- cor.mtest(data_SG_subset, conf.level = 0.95)
my_colors <- brewer.pal(3, "Dark2")[1:3]

coef_mat <- cor_SG         # 
coef_mat[res_SG$p > 0.05] <- NA  # NA if  p > 0.05
my_colors <- c(my_colors[1], my_colors[1], my_colors[2], my_colors[2], my_colors[2],my_colors[3] ) ## 2 lysi Trait, 3 LTP trait, 1 HTP trait 

png(filename = paste0(opPATH.fig, "correlation_SG_LTP_LYSI_HTP.png"), width = 800, height = 800)



# Plot
plot_SG <- corrplot(
  cor_SG, 
  method = "circle",
  type = "upper",
  tl.col = my_colors, 
  tl.srt = 45,
  addCoef.col = "black",      # coefficients en noir
  number.cex = 0.7,
  p.mat = res_SG$p,
  sig.level = 0.05,
  insig = "blank",            # ne rien afficher pour les non significatifs
  addCoefasPercent = FALSE,   # afficher les coefficients tels quels
  coef = coef_mat             # utiliser la matrice modifiée
)



dev.off()


```




#### pearl millet trials correlations (LTP 2025, Lysimeter 2025)

```{r import pearl millet data }
# PEARL MILLET 
# LYSI 2025
## TE
TE_mean_LYSI_PM_2025 <- read.csv(here::here(opPATH.results, "TE_mean_LYSI_PM_2025.csv"), dec = ".", sep = ";")
names(TE_mean_LYSI_PM_2025)[names(TE_mean_LYSI_PM_2025) == "TE"] <- "TEplant"

## SLOPE 
SLOPE_mean_LYSI_PM_2025 <- read.csv(here::here(opPATH.results, "SLOPE_mean_LYSI_PM_2025.csv"), dec = ".", sep = ";")
names(SLOPE_mean_LYSI_PM_2025)[names(SLOPE_mean_LYSI_PM_2025) == "SLOPE"] <- "Slope Lysimeter" # to differentiate between the slopes of the two trials
# LTP 2025
## SLOPE 
SLOPE_mean_LTP_PM_2025 <- read.csv(here::here(opPATH.results, "SLOPE_mean_LTP_PM_2025.csv"), dec = ".", sep = ";")
names(SLOPE_mean_LTP_PM_2025)[names(SLOPE_mean_LTP_PM_2025) == "SLOPE"] <- "Slope LTP" # to differentiate between the slopes of the two trials


## ROOT AREA
ROOT_AREA_mean_LTP_PM_2025 <- read.csv(here::here(opPATH.results, "ROOT_AREA_mean_LTP_PM_2025.csv"), dec = ".", sep = ";")
names(ROOT_AREA_mean_LTP_PM_2025)[names(ROOT_AREA_mean_LTP_PM_2025) == "ROOT_AREA"] <- "Root area "

## ROOT SHOOT 
ROOT_SHOOT_mean_LTP_PM_2025  <- read.csv(here::here(opPATH.results, "ROOT_SHOOT_mean_LTP_PM_2025.csv"), dec = ".", sep = ";")
names(ROOT_SHOOT_mean_LTP_PM_2025)[names(ROOT_SHOOT_mean_LTP_PM_2025) == "ROOT_SHOOT"] <- "Root Shoot"

nrow(TE_mean_LYSI_PM_2025)
nrow(SLOPE_mean_LYSI_PM_2025)
nrow(SLOPE_mean_LTP_PM_2025)
nrow(ROOT_AREA_mean_LTP_PM_2025)
nrow(ROOT_SHOOT_mean_LTP_PM_2025)



# create a list all  dfs
data_PM_list <- list(TE_mean_LYSI_PM_2025, SLOPE_mean_LYSI_PM_2025, SLOPE_mean_LTP_PM_2025,ROOT_AREA_mean_LTP_PM_2025, ROOT_SHOOT_mean_LTP_PM_2025 )
save(data_PM_list, file =  paste0(opPATH.obj, "data_PM_list.RData"))

# Merge them all by N_GENO
data_PM <- Reduce(function(x, y) merge(x, y, by = c("N_GENO", "GENO_NAME"), all = TRUE), data_PM_list)
nrow(data_PM)

data_PM$N_GENO = as.factor(data_PM$N_GENO)
data_PM$GENO_NAME = as.factor(data_PM$GENO_NAME)


data_PM_subset <- na.omit(data_PM[, 3:ncol(data_PM)]) ## does not accept NA 
# Recompute correlation and p-values
cor_PM <- cor(data_PM_subset, method = "pearson")  ##  Compute correlations and p-values
res_PM <- cor.mtest(data_PM_subset, conf.level = 0.95)
my_colors <- brewer.pal(3, "Dark2")[1:2]

coef_mat <- cor_PM          # 
coef_mat[res_PM$p > 0.05] <- NA  # NA if  p > 0.05

my_colors <- c(my_colors[1], my_colors[1], my_colors[2], my_colors[2], my_colors[2]) ## 2 lysi Trait, 3 LTP trait


png(filename = paste0(opPATH.fig, "correlation_PM_LTP_LYSI.png", width = 800, height = 800))



# Plot
plot_PM <- corrplot(
  cor_PM, 
  method = "circle",
  type = "upper",
  tl.col = my_colors, 
  tl.srt = 45,
  addCoef.col = "black",      # coefficients en noir
  number.cex = 0.7,
  p.mat = res_PM$p,
  sig.level = 0.05,
  insig = "blank",            # ne rien afficher pour les non significatifs
  addCoefasPercent = FALSE,   # afficher les coefficients tels quels
  coef = coef_mat             # utiliser la matrice modifiée
)


dev.off()


```



```{r}
my_colors <- brewer.pal(3, "Dark2")[1:3]

# SG: 2 Lysi, 3 LTP, 1 HTP
my_colors_SG <- c(
  rep(my_colors[1], 2),  # 2 lysi traits
  rep(my_colors[2], 3),  # 3 LTP traits
  rep(my_colors[3], 1)   # 1 HTP trait
)

# PM: 2 Lysi, 3 LTP
my_colors_PM <- c(
  rep(my_colors[1], 2),  # 2 lysi traits
  rep(my_colors[2], 3)   # 3 LTP traits
)
# --- Save PNG with 2 plots side by side ---
png(filename = paste(opPATH.fig,"corrplot_SG_PM.png"), width = 2000, height = 1000, res = 150)


par(mfrow = c(1, 2))  # 1 row, 2 columns




# Plot
plot_SG <- corrplot(
  cor_SG, 
  method = "circle",
  type = "upper",
  tl.col = my_colors_SG, 
  tl.srt = 45,
  addCoef.col = "black",      # coefficients en noir
  number.cex = 0.7,
  p.mat = res_SG$p,
  sig.level = 0.05,
  insig = "blank",            # ne rien afficher pour les non significatifs
  addCoefasPercent = FALSE,   # afficher les coefficients tels quels
  coef = coef_mat             # utiliser la matrice modifiée
)



mtext("a) Sorghum", side = 3, line = 1, cex = 1.2, font = 2)



# Plot correlation with coefficients shown
plot_PM <- corrplot(
  cor_PM, 
  method = "circle",
  type = "upper",
  tl.col = my_colors_PM, 
  tl.srt = 45,
  addCoef.col = "black",      # coefficients en noir
  number.cex = 0.7,
  p.mat = res_PM$p,
  sig.level = 0.05,
  insig = "blank",            # ne rien afficher pour les non significatifs
  addCoefasPercent = FALSE,   # afficher les coefficients tels quels
  coef = coef_mat             # utiliser la matrice modifiée
)

mtext("b) Pearl millet", side = 3, line = 1, cex = 1.2, font = 2)
dev.off()

```


```{r}
## LTP 2024

SLOPE_mean_LTP_SG= read.table(here::here(opPATH.results, "PHENO_LTP.txt"), header = TRUE)
names(SLOPE_mean_LTP_SG)[names(SLOPE_mean_LTP_SG) == "Code_ADN"] <- "GENO_NAME" # to differentiate between the slopes of the two trials
names(SLOPE_mean_LTP_SG)[names(SLOPE_mean_LTP_SG) == "ESTIMATE_THIES"] <- "SLOPE LTP" # to differentiate between the slopes of the two trials


# HTP 2023
SLOPE_mean_HTP_SG= read.table(here::here(opPATH.results, "PHENO_HTP.txt"), header = TRUE)
names(SLOPE_mean_HTP_SG)[names(SLOPE_mean_HTP_SG) == "GENOTYPE"] <- "GENO_NAME" # to differentiate between the slopes of the two trials
names(SLOPE_mean_HTP_SG)[names(SLOPE_mean_HTP_SG) == "ESTIMATE_HTP"] <- "SLOPE HTP" # to differentiate between the slopes of the two trials

## LYSI 
SLOPE_mean_LYSI_SG <- read.csv(here::here(opPATH.results, "PHENO_LYSI.txt"), header = TRUE, sep = "")
names(SLOPE_mean_LYSI_SG)[names(SLOPE_mean_LYSI_SG) == "Code_ADN"] <- "GENO_NAME"  # to differentiate between the slopes of the two trials
SLOPE_mean_LYSI_SG$ESTIMATE_BAMBEY = as.numeric(SLOPE_mean_LYSI_SG$ESTIMATE_BAMBEY)
names(SLOPE_mean_LYSI_SG)[names(SLOPE_mean_LYSI_SG) == "ESTIMATE_BAMBEY"] <- "SLOPE LYSIMETER" # to differentiate between the slopes of the two trials


# create a list all  dfs
data_SG_list <- list(SLOPE_mean_LYSI_SG, SLOPE_mean_LTP_SG, SLOPE_mean_HTP_SG ) 
save(data_SG_list, file =  paste0(opPATH.obj, "data_SG_list.RData"))



# Merge them all by N_GENO and GENO_NAME

data_SG <- Reduce(function(x, y) merge(x, y, by = c( "GENO_NAME"), all = TRUE), data_SG_list) # to fix correlactly find N_GENO for GENO NAME in HTP df 
nrow(data_SG)

data_SG$N_GENO = as.factor(data_SG$N_GENO)
data_SG$GENO_NAME = as.factor(data_SG$GENO_NAME)

data_SG <- subset(data_SG, select = -c(WEEK, GENOTYPE )) ## remove N_GENO suuplementary 



data_SG <- data_SG %>% relocate(N_GENO, .after = 1)

save(data_SG, file =  paste0(opPATH.obj, "data_SG.RData"))
data_SG = na.omit(data_SG)


data_SG_subset <- na.omit(data_SG[, 3:ncol(data_SG)]) ## does not accept NA 
# Recompute correlation and p-values
cor_SG <- cor(data_SG_subset, method = "pearson")  ##  Compute correlations and p-values
res_SG <- cor.mtest(data_SG_subset, conf.level = 0.95)
my_colors <- brewer.pal(3, "Dark2")[1:3]

coef_mat <- cor_SG         # 
coef_mat[res_SG$p > 0.05] <- NA  # NA if  p > 0.05
my_colors <- c(my_colors[1], my_colors[1], my_colors[2], my_colors[2], my_colors[2],my_colors[3] ) ## 2 lysi Trait, 3 LTP trait, 1 HTP trait 

if (dev.cur() != 1) dev.off()
png(filename = paste0(opPATH.fig, "correlation_SG_LTP_LYSI_HTP.png"),
    width = 800, height = 800)

if (!dir.exists(opPATH.fig)) dir.create(opPATH.fig, recursive = TRUE)
# Plot
plot_SG <- corrplot(
  cor_SG, 
  method = "circle",
  type = "upper",
  tl.col = my_colors, 
  tl.srt = 45,
  addCoef.col = "black",      # coefficients en noir
  number.cex = 0.7,
  p.mat = res_SG$p,
  sig.level = 0.05,
  insig = "blank",            # ne rien afficher pour les non significatifs
  addCoefasPercent = FALSE,   # afficher les coefficients tels quels
  coef = coef_mat             # utiliser la matrice modifiée
)



dev.off()




```


